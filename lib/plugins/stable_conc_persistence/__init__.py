# Copyright (c) 2019 Charles University in Prague, Faculty of Arts,
#                    Institute of the Czech National Corpus
# Copyright (c) 2019 Tomas Machalek <tomas.machalek@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2
# dated June, 1991.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Stable concordance persistence provides a solution where KonText runs mainly as API and
it is desired to have always the same key/hash for the same input data. Although not required,
it is recommended to run this along with API-friendly auth plug-in 'static_auth'.

Keys generated by this plug-in can be read by default_conc_persistence (and ucnk_conc_persistence2).
So it should be possible to mix two instances of KonText - one with stable_conc_persistence and
one with default_conc_persistence on top of the same database and generate working links from
'stable_conc_persistence' instance to the 'default_conc_persistence' (the opposite direction is
not supported).
"""


from plugins import inject
import plugins
from plugins.abstract.conc_persistence import AbstractConcPersistence
import json
import hashlib
import re


QUERY_KEY = 'q'
ID_KEY = 'id'
DEFAULT_TTL_DAYS = 7


def generate_stable_id(data):
    return hashlib.md5(json.dumps(data)).hexdigest()


def mk_key(code):
    return 'concordance:%s' % (code, )


class StableConcPersistence(AbstractConcPersistence):

    def __init__(self, db, ttl_days):
        self.db = db
        self._ttl_days = ttl_days

    @property
    def ttl(self):
        return self._ttl_days * 24 * 3600

    def is_valid_id(self, data_id):
        return bool(re.match(r'~[0-9a-f]+', data_id))

    def get_conc_ttl_days(self, user_id):
        return self._ttl_days

    def open(self, data_id):
        return self.db.get(mk_key(data_id))

    def store(self, user_id, curr_data, prev_data=None):

        def records_differ(r1, r2):
            return (r1[QUERY_KEY] != r2[QUERY_KEY] or
                    r1.get('lines_groups') != r2.get('lines_groups'))

        if prev_data is None or records_differ(curr_data, prev_data):
            data_id = generate_stable_id(curr_data)
            curr_data[ID_KEY] = data_id
            if prev_data is not None:
                curr_data['prev_id'] = prev_data['id']
            data_key = mk_key(data_id)
            self.db.set(data_key, curr_data)
            self.db.set_ttl(data_key, self.ttl)
            latest_id = curr_data[ID_KEY]
        else:
            latest_id = prev_data[ID_KEY]

        return latest_id

    def archive(self, user_id, conc_id, revoke=False):
        pass

    def is_archived(self, conc_id):
        return False


@inject(plugins.runtime.DB)
def create_instance(settings, db):
    plugin_conf = settings.get('plugins', 'conc_persistence')
    ttl_days = int(plugin_conf.get('default:ttl_days', DEFAULT_TTL_DAYS))

    return StableConcPersistence(db=db, ttl_days=ttl_days)
